import os
from os import listdir
import sys
import numpy as np
from numpy import array
import PIL
from PIL import Image as Im
import pickle
from diagram_toolkit import load_diagDirectory, rm_endpages

"""
Begins the diagram extraction process.

Identifies stray marks and letters - definite nondiag material - and
fades them while coloring potential diagrams to make a visual check
simple. 

Also records and pickles non-outlier max areas for ccs, widths
of 'definite' vertical lines, heights of 'definite' horizontal ones,
and dimensions for each full page. These will be used in future
scripts (roi_quad.py, roi_line.py, nolabel.py).

To be followed by a visual check, any necessary corrections, and then
confirm-diags.py.
"""

# Request work ID, confirm directory exists, and record path information
pathInfo = load_diagDirectory()
path = pathInfo[0]
work = pathInfo[1]
extension = pathInfo[2]

fileList = sorted(listdir(path + work + "/" + extension))

# Remove endpages
skip = rm_endpages(path, work, extension)





# Start Gamera portion of program

from gamera.core import *
init_gamera()
from gamera.plugins import draw
from diagram_toolkit import is_outlier, status_update, rect_extend_boundaries

if not os.path.exists(path + work + "/check/"):
  os.makedirs(path + work + "/check/")

# These lists and dictionary will be exported so later scripts can use 
# the normal areas, line widths/heights, and full page dimensions

page_norm_areas = {} 
vline_width = []
hline_height = []
page_dimensions = {}

for f in fileList:
  if f in skip:
    pass
  else:
    if ".png" in f:
      name = f[:-4]
    elif ".tiff" in f:
      name = f[:-5]
    elif ".tif" in f:
      name = f[:-4]

    img = load_image(path + work + "/" + extension + "/" + str(f))
    page_dimensions[str(f)] = img.ncols, img.nrows

    # Grab page dimensions

    if img.data.pixel_type != ONEBIT:
      print "WARNING: Image not yet binarized.\nBinarizing..."
      img = img.to_onebit()

    highlight = img.to_rgb()

    possDiags = []
    ccs = img.cc_analysis()

# Determine area outliers and get max non-outlier area

    area = []
    for c in ccs:
      a = (float(c.nrows)/float(img.nrows)) * (float(c.ncols)/float(img.ncols))
      area.append(a)

    np_area = array( area )
    filtered = np_area[~is_outlier(np_area)]
    max_norm_area = np.amax(filtered)

    page_norm_areas[name] = max_norm_area
  
    for c in ccs:
      a = ((float(c.ncols)/float(img.ncols)) * (float(c.nrows)/float(img.nrows)))
      ar = float(c.nrows) / float(c.ncols)
      x_offset = float(c.offset_x) / float(img.ncols)
      y_offset = float(c.offset_y) / float(img.nrows)

# Catches and greys out page edges

      if x_offset < 0.03 or x_offset > 0.97:
        highlight.highlight(c, RGBPixel(125,125,125))
      elif y_offset < 0.05 or y_offset > 0.95:
        highlight.highlight(c, RGBPixel(125,125,125))

# Catches 'definite' lines, based on surpassing a certain aspect ratio
# Note: these are not definite line *diags*
# Quite possible that this picks up page edges, crit app dividers, etc

      elif ar > 10:
        vline_width.append(c.ncols)
        highlight.highlight(c, RGBPixel(0,255,0))
        possDiags.append(Rect(c))
      elif ar < 0.1:
        hline_height.append(c.nrows)
        highlight.highlight(c, RGBPixel(0,255,0))
        possDiags.append(Rect(c))

# Catches large rois (potential 'quad' diags)

      elif a > (max_norm_area * 3):
        highlight.highlight(c, RGBPixel(255,0,0))
        possDiags.append(Rect(c))

# Catches potential lines

      elif ar > 4 or ar < 0.25:
        highlight.highlight(c, RGBPixel(0,0,255))
        possDiags.append(Rect(c))

# Colors the remainder grey for the visual check

      elif a < (max_norm_area * 3):
        highlight.highlight(c, RGBPixel(125,125,125))

#    highlight.save_PNG(path + work + "/check/" + name + ".png")

# Extend cc boundary boxes, find overlap, and export resulting images

    for c in possDiags:
      c = rect_extend_boundaries(c, img, 160)

    x = 0
    for x in range(0,4):
      for n in range(0, len(possDiags)):
        for m in range(0, len(possDiags)):
          if n == m:
            pass
          else:
            if possDiags[n].intersects(possDiags[m]):
              possDiags[n].union(possDiags[m])
      x = x + 1

    possDiags = set(possDiags)
    possDiags = list(possDiags)

    j = 0
    done = []
    for c in possDiags:
      j = j + 1
      if c not in done:
        highlight.draw_hollow_rect(c, RGBPixel(0,0,255), 5.0)
#        diag.save_PNG(path[:-5] + "diag/" + work + "/extracted_initial/" + name + "_d" + str(j) + ".png")
        done.append(c)

    highlight.save_PNG(path + work + "/check/" + name + ".png")

# Create empty corrections directory in case any are necessary

os.makedirs(path + work + "/corr/")
os.makedirs(path + work + "/extracted_initial/")

# Pickle area and line records

area_record = open(path + work + '/page_norm_areas.pickle', mode ='wb')
pickle.dump(page_norm_areas, area_record)
area_record.close()

vline_record = open(path + work + '/vline_widths.pickle', mode ='wb')
pickle.dump(vline_width, vline_record)
vline_record.close()

hline_record = open(path + work + '/hline_heights.pickle', mode ='wb')
pickle.dump(hline_height, hline_record)
hline_record.close()

dimension_record = open(path + work + '/page_dimensions.pickle', mode ='wb')
pickle.dump(page_dimensions, dimension_record)
dimension_record.close()

# Update and save new status file

# status_update("/home/chris/Github/x_eu-diagrams/status.csv",work,5)
